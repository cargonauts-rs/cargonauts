<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `SubLevel` enum in crate `mime`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, SubLevel">

    <title>mime::SubLevel - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc enum">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>mime</a></p><script>window.sidebarCurrent = {name: 'SubLevel', ty: 'enum', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Enum <a href='index.html'>mime</a>::<wbr><a class="enum" href=''>SubLevel</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/mime/lib.rs.html#139-142' title='goto source code'>[src]</a></span></h1>
<pre class='rust enum'>pub enum SubLevel {
    Star,
    Plain,
    Html,
    Xml,
    Javascript,
    Css,
    EventStream,
    Json,
    WwwFormUrlEncoded,
    Msgpack,
    OctetStream,
    FormData,
    Png,
    Gif,
    Bmp,
    Jpeg,
    Mpeg,
    Mp4,
    Ogg,
    Ext(<a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a>),
}</pre><h2 class='variants'>Variants</h2>
<span id='variant.Star' class='variant'><span id='Star.v' class='invisible'><code>Star</code></span></span><span id='variant.Plain' class='variant'><span id='Plain.v' class='invisible'><code>Plain</code></span></span><span id='variant.Html' class='variant'><span id='Html.v' class='invisible'><code>Html</code></span></span><span id='variant.Xml' class='variant'><span id='Xml.v' class='invisible'><code>Xml</code></span></span><span id='variant.Javascript' class='variant'><span id='Javascript.v' class='invisible'><code>Javascript</code></span></span><span id='variant.Css' class='variant'><span id='Css.v' class='invisible'><code>Css</code></span></span><span id='variant.EventStream' class='variant'><span id='EventStream.v' class='invisible'><code>EventStream</code></span></span><span id='variant.Json' class='variant'><span id='Json.v' class='invisible'><code>Json</code></span></span><span id='variant.WwwFormUrlEncoded' class='variant'><span id='WwwFormUrlEncoded.v' class='invisible'><code>WwwFormUrlEncoded</code></span></span><span id='variant.Msgpack' class='variant'><span id='Msgpack.v' class='invisible'><code>Msgpack</code></span></span><span id='variant.OctetStream' class='variant'><span id='OctetStream.v' class='invisible'><code>OctetStream</code></span></span><span id='variant.FormData' class='variant'><span id='FormData.v' class='invisible'><code>FormData</code></span></span><span id='variant.Png' class='variant'><span id='Png.v' class='invisible'><code>Png</code></span></span><span id='variant.Gif' class='variant'><span id='Gif.v' class='invisible'><code>Gif</code></span></span><span id='variant.Bmp' class='variant'><span id='Bmp.v' class='invisible'><code>Bmp</code></span></span><span id='variant.Jpeg' class='variant'><span id='Jpeg.v' class='invisible'><code>Jpeg</code></span></span><span id='variant.Mpeg' class='variant'><span id='Mpeg.v' class='invisible'><code>Mpeg</code></span></span><span id='variant.Mp4' class='variant'><span id='Mp4.v' class='invisible'><code>Mp4</code></span></span><span id='variant.Ogg' class='variant'><span id='Ogg.v' class='invisible'><code>Ogg</code></span></span><span id='variant.Ext' class='variant'><span id='Ext.v' class='invisible'><code>Ext(<a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a>)</code></span></span><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#144-151' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.as_str' class="method"><span id='as_str.v' class='invisible'><code>fn <a href='#method.as_str' class='fnname'>as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></h4>
</div><h2 id='deref-methods'>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html" title="trait core::ops::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</h2><div class='impl-items'><h4 id='method.len' class="method"><span id='len.v' class='invisible'><code>fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html"><code>char</code></a>s or graphemes. In other words,
it may not be what a human considers the length of the string.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">len</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">3</span>, <span class="ident">len</span>);

<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;ƒoo&quot;</span>.<span class="ident">len</span>(); <span class="comment">// fancy f!</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">len</span>);</pre>
</div><h4 id='method.is_empty' class="method"><span id='is_empty.v' class='invisible'><code>fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_empty</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_empty</span>());</pre>
</div><h4 id='method.is_char_boundary' class="method"><span id='is_char_boundary.v' class='invisible'><code>fn <a href='#method.is_char_boundary' class='fnname'>is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.9.0'>1.9.0</div></span></h4>
<div class='docblock'><p>Checks that <code>index</code>-th byte lies at the start and/or end of a
UTF-8 code point sequence.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be
boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">0</span>));
<span class="comment">// start of `老`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">6</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="ident">s</span>.<span class="ident">len</span>()));

<span class="comment">// second byte of `ö`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">2</span>));

<span class="comment">// third byte of `老`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">8</span>));</pre>
</div><h4 id='method.as_bytes' class="method"><span id='as_bytes.v' class='invisible'><code>fn <a href='#method.as_bytes' class='fnname'>as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Converts a string slice to a byte slice.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">as_bytes</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">b&quot;bors&quot;</span>, <span class="ident">bytes</span>);</pre>
</div><h4 id='method.as_ptr' class="method"><span id='as_ptr.v' class='invisible'><code>fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();</pre>
</div><h4 id='method.get' class="method"><span id='get.v' class='invisible'><code>fn <a href='#method.get' class='fnname'>get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;I::<a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">Output</a>&gt; <span class="where fmt-newline">where I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</span></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>str_checked_slicing</code>)</div></div><div class='docblock'><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns <code>None</code> whenever
equivalent indexing operation would panic.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;🗻∈🌏&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;🗻&quot;</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>..).<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">8</span>).<span class="ident">is_none</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());</pre>
</div><h4 id='method.get_unchecked' class="method"><span id='get_unchecked.v' class='invisible'><code>unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;I::<a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">Output</a> <span class="where fmt-newline">where I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</span></code></span></h4>
<div class='stability'><div class='stab unstable'><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>str_checked_slicing</code>)</div></div><div class='docblock'><p>Returns a unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must come before the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;🗻∈🌏&quot;</span>;
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;🗻&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;∈&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;🌏&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">7</span>..<span class="number">11</span>));
}</pre>
</div><h4 id='method.slice_unchecked' class="method"><span id='slice_unchecked.v' class='invisible'><code>unsafe fn <a href='#method.slice_unchecked' class='fnname'>slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must come before <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Löwe 老虎 Léopard&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;world&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">7</span>, <span class="number">12</span>));
}</pre>
</div><h4 id='method.split_at' class="method"><span id='split_at.v' class='invisible'><code>fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a></code><div class='since' title='Stable since Rust version 1.4.0'>1.4.0</div></span></h4>
<div class='docblock'><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="#method.split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
beyond the last code point of the string slice.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-Löf&quot;</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at</span>(<span class="number">3</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Per&quot;</span>, <span class="ident">first</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Martin-Löf&quot;</span>, <span class="ident">last</span>);</pre>
</div><h4 id='method.chars' class="method"><span id='chars.v' class='invisible'><code>fn <a href='#method.chars' class='fnname'>chars</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Chars.html" title="struct core::str::Chars">Chars</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over the <code>char</code>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns such an iterator.</p>
<p>It's important to remember that <a href="primitive.char.html"><code>char</code></a> represents a Unicode Scalar
Value, and may not match your idea of what a 'character' is. Iteration
over grapheme clusters may be what you actually want.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s may not match your human intuition about characters:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;y̆&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>()); <span class="comment">// not &#39;y̆&#39;</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.char_indices' class="method"><span id='char_indices.v' class='invisible'><code>fn <a href='#method.char_indices' class='fnname'>char_indices</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.CharIndices.html" title="struct core::str::CharIndices">CharIndices</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html"><code>char</code></a> is
second.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>().<span class="ident">count</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s may not match your human intuition about characters:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;y̆&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>()); <span class="comment">// not (0, &#39;y̆&#39;)</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.bytes' class="method"><span id='bytes.v' class='invisible'><code>fn <a href='#method.bytes' class='fnname'>bytes</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Bytes.html" title="struct core::str::Bytes">Bytes</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">bytes</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">bytes</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.split_whitespace' class="method"><span id='split_whitespace.v' class='invisible'><code>fn <a href='#method.split_whitespace' class='fnname'>split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/std_unicode/u_str/struct.SplitWhitespace.html" title="struct std_unicode::u_str::SplitWhitespace">SplitWhitespace</a></code><div class='since' title='Stable since Rust version 1.1.0'>1.1.0</div></span></h4>
<div class='docblock'><p>Split a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_whitespace</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre>
<p>All kinds of whitespace are considered:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.<span class="ident">split_whitespace</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.lines' class="method"><span id='lines.v' class='invisible'><code>fn <a href='#method.lines' class='fnname'>lines</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Lines.html" title="struct core::str::Lines">Lines</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with
a line feed (<code>\r\n</code>).</p>
<p>The final line ending is optional.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre>
<p>The final line ending isn't required:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</pre>
</div><h4 id='method.lines_any' class="method"><span id='lines_any.v' class='invisible'><code>fn <a href='#method.lines_any' class='fnname'>lines_any</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.LinesAny.html" title="struct core::str::LinesAny">LinesAny</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='stability'><div class='stab deprecated'>Deprecated since 1.4.0<p>: use lines() instead now</p>
</div></div><div class='docblock'><p>An iterator over the lines of a string.</p>
</div><h4 id='method.encode_utf16' class="method"><span id='encode_utf16.v' class='invisible'><code>fn <a href='#method.encode_utf16' class='fnname'>encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/str/struct.EncodeUtf16.html" title="struct collections::str::EncodeUtf16">EncodeUtf16</a></code><div class='since' title='Stable since Rust version 1.8.0'>1.8.0</div></span></h4>
<div class='docblock'><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
</div><h4 id='method.contains' class="method"><span id='contains.v' class='invisible'><code>fn <a href='#method.contains' class='fnname'>contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;apples&quot;</span>));</pre>
</div><h4 id='method.starts_with' class="method"><span id='starts_with.v' class='invisible'><code>fn <a href='#method.starts_with' class='fnname'>starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;nana&quot;</span>));</pre>
</div><h4 id='method.ends_with' class="method"><span id='ends_with.v' class='invisible'><code>fn <a href='#method.ends_with' class='fnname'>ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;nana&quot;</span>));</pre>
</div><h4 id='method.find' class="method"><span id='find.v' class='invisible'><code>fn <a href='#method.find' class='fnname'>find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;Léopard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));</pre>
<p>More complex patterns with closures:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">1</span>));</pre>
<p>Not finding the pattern:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[_] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre>
</div><h4 id='method.rfind' class="method"><span id='rfind.v' class='invisible'><code>fn <a href='#method.rfind' class='fnname'>rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns the byte index of the last character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None"><code>None</code></a> if the pattern doesn't match.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;é&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));</pre>
<p>More complex patterns with closures:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char</span>::<span class="ident">is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));</pre>
<p>Not finding the pattern:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Löwe 老虎 Léopard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[_] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</pre>
</div><h4 id='method.split' class="method"><span id='split.v' class='invisible'><code>fn <a href='#method.split' class='fnname'>split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Split.html" title="struct core::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior" class="section-header"><a href="#iterator-behavior">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit"><code>rsplit</code></a> method can be used.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1def2ghi&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="ident">char</span>::<span class="ident">is_uppercase</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</pre>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;||||a||b|c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;|&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>Contiguous separators are separated by the empty string.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;(///)&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;/&#39;</span>).<span class="ident">collect</span>();;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</pre>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;010&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">f</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;rust&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;    a  b c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>It does <em>not</em> give you:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</pre>
<p>Use <a href="#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div><h4 id='method.rsplit' class="method"><span id='rsplit.v' class='invisible'><code>fn <a href='#method.rsplit' class='fnname'>rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplit.html" title="struct core::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior-1" class="section-header"><a href="#iterator-behavior-1">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split"><code>split</code></a> method can be used.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</pre>
</div><h4 id='method.split_terminator' class="method"><span id='split_terminator.v' class='invisible'><code>fn <a href='#method.split_terminator' class='fnname'>split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitTerminator.html" title="struct core::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-2" class="section-header"><a href="#iterator-behavior-2">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);</pre>
</div><h4 id='method.rsplit_terminator' class="method"><span id='rsplit_terminator.v' class='invisible'><code>fn <a href='#method.rsplit_terminator' class='fnname'>rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitTerminator.html" title="struct core::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The pattern can be a simple <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines the split.
Additional libraries might provide more complex patterns like
regular expressions.</p>
<p>Equivalent to <a href="#method.split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h1 id="iterator-behavior-3" class="section-header"><a href="#iterator-behavior-3">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);</pre>
</div><h4 id='method.splitn' class="method"><span id='splitn.v' class='invisible'><code>fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.SplitN.html" title="struct core::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines the
split.</p>
<h1 id="iterator-behavior-4" class="section-header"><a href="#iterator-behavior-4">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="#method.rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lambda&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXdef&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</pre>
</div><h4 id='method.rsplitn' class="method"><span id='rsplitn.v' class='invisible'><code>fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RSplitN.html" title="struct core::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines the split.</p>
<h1 id="iterator-behavior-5" class="section-header"><a href="#iterator-behavior-5">Iterator behavior</a></h1>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="#method.splitn"><code>splitn</code></a> method can be used.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</pre>
</div><h4 id='method.matches' class="method"><span id='matches.v' class='invisible'><code>fn <a href='#method.matches' class='fnname'>matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.Matches.html" title="struct core::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div></span></h4>
<div class='docblock'><p>An iterator over the matches of a pattern within the given string
slice.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines if a character matches.</p>
<h1 id="iterator-behavior-6" class="section-header"><a href="#iterator-behavior-6">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatches"><code>rmatches</code></a> method can be used.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">matches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</pre>
</div><h4 id='method.rmatches' class="method"><span id='rmatches.v' class='invisible'><code>fn <a href='#method.rmatches' class='fnname'>rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatches.html" title="struct core::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div></span></h4>
<div class='docblock'><p>An iterator over the matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="iterator-behavior-7" class="section-header"><a href="#iterator-behavior-7">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.matches"><code>matches</code></a> method can be used.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">rmatches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</pre>
</div><h4 id='method.match_indices' class="method"><span id='match_indices.v' class='invisible'><code>fn <a href='#method.match_indices' class='fnname'>match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.MatchIndices.html" title="struct core::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines
if a character matches.</p>
<h1 id="iterator-behavior-8" class="section-header"><a href="#iterator-behavior-8">Iterator behavior</a></h1>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, eg, <a href="primitive.char.html"><code>char</code></a> but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></pre>
</div><h4 id='method.rmatch_indices' class="method"><span id='rmatch_indices.v' class='invisible'><code>fn <a href='#method.rmatch_indices' class='fnname'>rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/struct.RMatchIndices.html" title="struct core::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.5.0'>1.5.0</div></span></h4>
<div class='docblock'><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if a
character matches.</p>
<h1 id="iterator-behavior-9" class="section-header"><a href="#iterator-behavior-9">Iterator behavior</a></h1>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="#method.match_indices"><code>match_indices</code></a> method can be used.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></pre>
</div><h4 id='method.trim' class="method"><span id='trim.v' class='invisible'><code>fn <a href='#method.trim' class='fnname'>trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim</span>());</pre>
</div><h4 id='method.trim_left' class="method"><span id='trim_left.v' class='invisible'><code>fn <a href='#method.trim_left' class='fnname'>trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with leading whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality" class="section-header"><a href="#text-directionality">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_left</span>());</pre>
<p>Directionality:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  עברית&quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ע&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</pre>
</div><h4 id='method.trim_right' class="method"><span id='trim_right.v' class='invisible'><code>fn <a href='#method.trim_right' class='fnname'>trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with trailing whitespace removed.</p>
<p>'Whitespace' is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h1 id="text-directionality-1" class="section-header"><a href="#text-directionality-1">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_right</span>());</pre>
<p>Directionality:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;עברית  &quot;</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;ת&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</pre>
</div><h4 id='method.trim_matches' class="method"><span id='trim_matches.v' class='invisible'><code>fn <a href='#method.trim_matches' class='fnname'>trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The pattern can be a <a href="primitive.char.html"><code>char</code></a> or a closure that determines if a
character matches.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[_] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.<span class="ident">trim_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</pre>
</div><h4 id='method.trim_left_matches' class="method"><span id='trim_left_matches.v' class='invisible'><code>fn <a href='#method.trim_left_matches' class='fnname'>trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that determines if
a character matches.</p>
<h1 id="text-directionality-2" class="section-header"><a href="#text-directionality-2">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Left' in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>right</em> side, not the left.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[_] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</pre>
</div><h4 id='method.trim_right_matches' class="method"><span id='trim_right_matches.v' class='invisible'><code>fn <a href='#method.trim_right_matches' class='fnname'>trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The pattern can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, or a closure that
determines if a character matches.</p>
<h1 id="text-directionality-3" class="section-header"><a href="#text-directionality-3">Text directionality</a></h1>
<p>A string is a sequence of bytes. 'Right' in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are 'right to left' rather than 'left to right', this will be
the <em>left</em> side, not the right.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<p>Simple patterns:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[_] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</pre>
<p>A more complex pattern, using a closure:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">||</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;fooX&quot;</span>);</pre>
</div><h4 id='method.parse' class="method"><span id='parse.v' class='invisible'><code>fn <a href='#method.parse' class='fnname'>parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, F::<a class="trait" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html" title="trait core::str::FromStr">Err</a>&gt; <span class="where fmt-newline">where F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Parses this string slice into another type.</p>
<p>Because <code>parse()</code> is so general, it can cause problems with type
inference. As such, <code>parse()</code> is one of the few times you'll see
the syntax affectionately known as the 'turbofish': <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
you're trying to parse into.</p>
<p><code>parse()</code> can parse any type that implements the <a href="str/trait.FromStr.html"><code>FromStr</code></a> trait.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err"><code>Err</code></a> if it's not possible to parse this string slice into
the desired type.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Basic usage</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">4</span>, <span class="ident">four</span>);</pre>
<p>Using the 'turbofish' instead of annotating <code>four</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="ident">four</span>);</pre>
<p>Failing to parse:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">nope</span> <span class="op">=</span> <span class="string">&quot;j&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">nope</span>.<span class="ident">is_err</span>());</pre>
</div><h4 id='method.replace' class="method"><span id='replace.v' class='invisible'><code>fn <a href='#method.replace' class='fnname'>replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;this is new&quot;</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));</pre>
<p>When the pattern doesn't match:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</pre>
</div><h4 id='method.replacen' class="method"><span id='replacen.v' class='invisible'><code>fn <a href='#method.replacen' class='fnname'>replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a> <span class="where fmt-newline">where P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;</span></code><div class='since' title='Stable since Rust version 1.16.0'>1.16.0</div></span></h4>
<div class='docblock'><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="string/struct.String.html"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>N</code> times.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="ident">char</span>::<span class="ident">is_numeric</span>, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</pre>
<p>When the pattern doesn't match:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</pre>
</div><h4 id='method.to_lowercase' class="method"><span id='to_lowercase.v' class='invisible'><code>fn <a href='#method.to_lowercase' class='fnname'>to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div></span></h4>
<div class='docblock'><p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Lowercase' is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">s</span>.<span class="ident">to_lowercase</span>());</pre>
<p>A tricky example, with sigma:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">sigma</span> <span class="op">=</span> <span class="string">&quot;Σ&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;σ&quot;</span>, <span class="ident">sigma</span>.<span class="ident">to_lowercase</span>());

<span class="comment">// but at the end of a word, it&#39;s ς, not σ:</span>
<span class="kw">let</span> <span class="ident">odysseus</span> <span class="op">=</span> <span class="string">&quot;ὈΔΥΣΣΕΎΣ&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;ὀδυσσεύς&quot;</span>, <span class="ident">odysseus</span>.<span class="ident">to_lowercase</span>());</pre>
<p>Languages without case are not changed:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_lowercase</span>());</pre>
</div><h4 id='method.to_uppercase' class="method"><span id='to_uppercase.v' class='invisible'><code>fn <a href='#method.to_uppercase' class='fnname'>to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code><div class='since' title='Stable since Rust version 1.2.0'>1.2.0</div></span></h4>
<div class='docblock'><p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.String.html"><code>String</code></a>.</p>
<p>'Uppercase' is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="ident">s</span>.<span class="ident">to_uppercase</span>());</pre>
<p>Scripts without case are not changed:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;农历新年&quot;</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_uppercase</span>());</pre>
</div><h4 id='method.escape_debug' class="method"><span id='escape_debug.v' class='invisible'><code>fn <a href='#method.escape_debug' class='fnname'>escape_debug</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <code>char::escape_debug</code>.</p>
</div><h4 id='method.escape_default' class="method"><span id='escape_default.v' class='invisible'><code>fn <a href='#method.escape_default' class='fnname'>escape_default</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <code>char::escape_default</code>.</p>
</div><h4 id='method.escape_unicode' class="method"><span id='escape_unicode.v' class='invisible'><code>fn <a href='#method.escape_unicode' class='fnname'>escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='stability'><div class='stab unstable'><details><summary><span class=microscope>🔬</span> This is a nightly-only experimental API.  (<code>str_escape</code>)</summary><p>return type may change to be an iterator</p>
</details></div></div><div class='docblock'><p>Escapes each char in <code>s</code> with <code>char::escape_unicode</code>.</p>
</div><h4 id='method.into_string' class="method"><span id='into_string.v' class='invisible'><code>fn <a href='#method.into_string' class='fnname'>into_string</a>(self: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code><div class='since' title='Stable since Rust version 1.4.0'>1.4.0</div></span></h4>
<div class='docblock'><p>Converts a <code>Box&lt;str&gt;</code> into a <a href="string/struct.String.html"><code>String</code></a> without copying or allocating.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;birthday gift&quot;</span>);
<span class="kw">let</span> <span class="ident">boxed_str</span> <span class="op">=</span> <span class="ident">string</span>.<span class="ident">clone</span>().<span class="ident">into_boxed_str</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">boxed_str</span>.<span class="ident">into_string</span>(), <span class="ident">string</span>);</pre>
</div><h4 id='method.repeat' class="method"><span id='repeat.v' class='invisible'><code>fn <a href='#method.repeat' class='fnname'>repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code><div class='since' title='Stable since Rust version 1.16.0'>1.16.0</div></span></h4>
<div class='docblock'><p>Create a <a href="string/struct.String.html"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<p>Basic usage:</p>

<pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;abc&quot;</span>.<span class="ident">repeat</span>(<span class="number">4</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;abcabcabcabc&quot;</span>));</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.clone' class="method"><span id='clone.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span></h4>
<div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><span id='clone_from.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.hash' class="method"><span id='hash.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;__H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, __arg_0: &amp;mut __H)</code></span></h4>
<div class='docblock'><p>Feeds this value into the state given, updating the hasher as necessary.</p>
</div><h4 id='method.hash_slice' class="method"><span id='hash_slice.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where fmt-newline">where H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a></span></code><div class='since' title='Stable since Rust version 1.3.0'>1.3.0</div></span></h4>
<div class='docblock'><p>Feeds a slice of this type into the state provided.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.cmp' class="method"><span id='cmp.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp' class='fnname'>cmp</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></code></span></h4>
<div class='docblock'><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#138' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.partial_cmp' class="method"><span id='partial_cmp.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code></span></h4>
<div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt' class="method"><span id='lt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le' class="method"><span id='le.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt' class="method"><span id='gt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge' class="method"><span id='ge.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html" title="trait core::ops::Deref">Deref</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#153-158' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedtype.Target' class="type"><span id='Target.t' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html#associatedtype.Target' class="type">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></h4>
<div class='docblock'><p>The resulting type after dereferencing</p>
</div><h4 id='method.deref' class="method"><span id='deref.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></h4>
<div class='docblock'><p>The method called to dereference a value</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#160-168' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.eq' class="method"><span id='eq.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method"><span id='ne.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a>&gt; for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#170-174' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.eq-1' class="method"><span id='eq.v-1' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-1' class="method"><span id='ne.v-1' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#176-180' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.eq-2' class="method"><span id='eq.v-2' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-2' class="method"><span id='ne.v-2' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#182-186' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.eq-3' class="method"><span id='eq.v-3' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-3' class="method"><span id='ne.v-3' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#206-213' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt-1' class="method"><span id='fmt.v-1' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></h4>
<div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html" title="trait core::str::FromStr">FromStr</a> for <a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/mime/lib.rs.html#215-223' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='associatedtype.Err' class="type"><span id='Err.t' class='invisible'><code>type <a href='https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html#associatedtype.Err' class="type">Err</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a></code></span></h4>
<div class='docblock'><p>The associated error which can be returned from parsing.</p>
</div><h4 id='method.from_str' class="method"><span id='from_str.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html#tymethod.from_str' class='fnname'>from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../mime/enum.SubLevel.html" title="enum mime::SubLevel">SubLevel</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">()</a>&gt;</code></span></h4>
<div class='docblock'><p>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/nightly/core/str/trait.FromStr.html#tymethod.from_str">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "mime";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>